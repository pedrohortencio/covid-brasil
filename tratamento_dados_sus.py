# -*- coding: utf-8 -*-
"""tratamento-dados-sus.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yE4ktNsRCxRmUTXRlSd6LZTl5YHuI1px

# Importação de bibliotecas
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import re

import urllib.request
import os
from collections import Counter

# Opção para que o Pandas não formate os números para notação científica
pd.set_option('display.float_format', str)
#pd.set_option('display.max_rows', 100)
#pd.reset_option("all")

URL_2019 = 'https://raw.githubusercontent.com/pedrohortencio/covid-brasil/main/Dados/SUS/2019-total.csv'
URL_2020 = 'https://raw.githubusercontent.com/pedrohortencio/covid-brasil/main/Dados/SUS/2020-total.csv'
CAMINHO_2019 = '/content/dados-2019-tot.csv'
CAMINHO_2020 = '/content/dados-2020-tot.csv'

MESES = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", 
         "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]

"""# Download dos Dados"""

def baixar_dados():
    # Baixa um .txt que contém a URL dos 24 .csv que compõe os dados mensais do SUS entre 2019 e 2020
    urls_dados_sus = 'https://raw.githubusercontent.com/pedrohortencio/covid-brasil/main/Dados/url-dados-sus.txt'
    _, _ = urllib.request.urlretrieve(urls_dados_sus, filename="/content/url-dados-sus.txt")
    # Abre o arquivo
    with open('/content/url-dados-sus.txt') as f:
        urls_csvs_sus = [line.rstrip() for line in f]   # cria uma lista com as URL

    # Cria os diretórios para os dados
    try:
        os.mkdir('/content/2019')
        os.mkdir('/content/2020')
    except:
        pass
    lista_caminhos = []
    # Percorre a lista baixando os arquivos
    for url in urls_csvs_sus:
        # Há duas linhas com valores '2019' e '2020'
        if url == '2019':
            pasta = '2019'  # altera o valor da variável pasta quando a linha for '2019'
            continue    # próxima iteração do loop
        elif url == '2020': 
            pasta = '2020'  # altera o valor para 2020
            continue    # próxima iteração do loop
        
        
        nome_arquivo = re.search('[0-9\-a-zA-Z]*[0-9]+.[a-z]+', url).group(0)   # Filtra o nome do arquivo da URL
        caminho = f"/content/{pasta}/{nome_arquivo}"    # Cria uma String com o caminho do arquivo
        lista_caminhos.append(caminho)
        _, _ = urllib.request.urlretrieve(url, filename=caminho) # Requisição do arquivo, salvando na pasta criada anteriormente
    return lista_caminhos

"""# Limpeza dos Dados"""

def ler_df_anual(caminho):
    df = pd.read_csv(caminho, sep=';', encoding='latin-1', header=4, decimal=',')   # lê o arquivo e cria um DataFrame
    df.dropna(axis = 0, thresh=9, inplace = True)

    df.replace({'-':0}, inplace=True)

    df['Óbitos'] = pd.to_numeric(df['Óbitos'], errors='coerce')
    df['Taxa_mortalidade'] = df['Taxa_mortalidade'].apply(lambda x: float(str(x).replace(',', '.')))

    ######################
    # Sanity check 1
        ### Verifica se há algum valor nulo em alguma coluna do DataFrame
    lista_valores_nulos = df.isnull().sum().sort_values(ascending=False).values
    for valor in lista_valores_nulos:
        if valor != 0:
            # Se sim, levanta uma exceção
            raise Exception("Há valores nulos no dataframe")

    # Sanity check 2
        ### Verifica se os dtypes do dataframe são os dtypes corretos, estabelecidos durante os testes
    lista_dtypes_corretos = [np.dtype('O'), np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('int64'), np.dtype('float64')]

    lista_dtypes = df.dtypes.values
    comparacao = lista_dtypes_corretos == lista_dtypes

    for i in comparacao:
        if np.logical_not(i):   # Se o valor i da lista é Falso
            raise Exception("Há dtypes incorretos no dataframe")
    #######################

    # Filtra as linhas onde a coluna "Lista Morb CID-10" exibe um dos capítulos do CID (1-21)
    df_grupo_cid = df[df['Lista Morb  CID-10'].str.match(r'[0-9]+')]

    lista_caps_cid = list(df_grupo_cid['Lista Morb  CID-10'].values)

    range_index = list(df_grupo_cid['Lista Morb  CID-10'].index)

    lista_qtd_repeticoes = []
    for indice, valor in enumerate(range_index):
        if indice == 19:
            diferenca = df.index[-1] - valor + 1
            lista_qtd_repeticoes.append(diferenca)
            continue
        
        diferenca = range_index[indice+1] - valor
        lista_qtd_repeticoes.append(diferenca)

    index_grupos_cid = []
    for grupo_cid, qtd_repeticoes in zip(lista_caps_cid, lista_qtd_repeticoes):
        for i in range(qtd_repeticoes):
            index_grupos_cid.append(grupo_cid.title())

    index_grupos_cid[-1] = 'Total'  # O último item do índice hierárquico será o valor total das colunas

    #########
    # Sanity Check 3
        ### Verifica se o tamanho da lista de grupos CID, para indexar hierarquicamente o dataframe, está correta
    if len(index_grupos_cid) != 348:
        raise Exception("Tamanho da lista de grupos CID, para indexação do DataFrame, não corresponde a 348 entradas")
    #########

    # Cria um índice hierárquico
    df.set_index([index_grupos_cid, [i for i in range(348)]], inplace=True)

    # Troca o valor da linha, na coluna 'Lista Morb  CID-10', para refletir o total do grupo
    df.loc[df.loc[:]['Lista Morb  CID-10'].str.match(r'[0-9]+'), 'Lista Morb  CID-10'] = 'Total do Grupo'

    # Retira os pontos no início das strings dos valores da coluna 'Lista Morb  CID-10'
    df.loc[:]['Lista Morb  CID-10'] = df.loc[:]['Lista Morb  CID-10'].apply(lambda x: x.strip('.'))

    return df

def ler_df(caminho):
    df = pd.read_csv(caminho, sep=';', encoding='latin-1', header=4, decimal=',')   # lê o arquivo e cria um DataFrame
    df.dropna(axis = 0, thresh=9, inplace = True)   # Dropa linhas que contenham mais de 9 valores NaN.

    ### O Ministério da Saúde convencionou que "Dados numéricos iguais a 0, não resultantes de arredondamento" são
    #representados por "-" (informação disponível no TabNet). Assim, esse valor será substituído por 0:
    df.replace({'-':0}, inplace=True)

    # Transforma a coluna "Óbitos" em valores numéricos (int64)
    df['Óbitos'] = pd.to_numeric(df['Óbitos'], errors='coerce')     # erros='coerce' faz com que valores problemáticos sejam inseridos como NaN
    # Converte a coluna "Taxa_mortalidade" para float64
    df['Taxa_mortalidade'] = df['Taxa_mortalidade'].apply(lambda x: float(str(x).replace(',', '.')))    #substitui a vírgula do decimal por ponto, converte para float64
    df['Média_permanência'] = df['Média_permanência'].apply(lambda x: float(str(x).replace(',', '.')))
    df['Dias_permanência'] = df['Dias_permanência'].apply(lambda x: float(str(x))) 

    ##################
    # Sanity check 1
        ### Verifica se há algum valor nulo em alguma coluna do DataFrame
    lista_valores_nulos = df.isnull().sum().sort_values(ascending=False).values
    for valor in lista_valores_nulos:
        if valor != 0:
            # Se sim, levanta uma exceção
            raise Exception("Há valores nulos no dataframe")

    # Sanity check 2
        ### Verifica se os dtypes do dataframe são os dtypes corretos, estabelecidos durante os testes
    lista_dtypes_corretos = [np.dtype('O'), np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('float64'), np.dtype('float64'), np.dtype('float64'),
        np.dtype('int64'), np.dtype('float64')]

    lista_dtypes = df.dtypes.values
    comparacao = lista_dtypes_corretos == lista_dtypes

    for i in comparacao:
        if np.logical_not(i):   # Se o valor i da lista é Falso
            raise Exception("Há dtypes incorretos no dataframe")
    #######################

    ### Criando um Índice Hierárquivo

    # Filtra as linhas onde a coluna "Lista Morb CID-10" exibe um dos capítulos do CID (1-21)
    df_grupo_cid = df[df['Lista Morb  CID-10'].str.match(r'[0-9]+')]

    lista_caps_cid = list(df_grupo_cid['Lista Morb  CID-10'].values)

    range_index = list(df_grupo_cid['Lista Morb  CID-10'].index)

    lista_qtd_repeticoes = []
    for indice, valor in enumerate(range_index):
        if indice == 19:
            diferenca = df.index[-1] - valor + 1
            lista_qtd_repeticoes.append(diferenca)
            continue
        
        diferenca = range_index[indice+1] - valor
        lista_qtd_repeticoes.append(diferenca)

    index_grupos_cid = []
    for grupo_cid, qtd_repeticoes in zip(lista_caps_cid, lista_qtd_repeticoes):
        for i in range(qtd_repeticoes):
            index_grupos_cid.append(grupo_cid.title())

    index_grupos_cid[-1] = 'Total'  # O último item do índice hierárquico será o valor total das colunas

    #########
    # Sanity Check 3
        ### Verifica se o tamanho da lista de grupos CID, para indexar hierarquicamente o dataframe, está correta
    #if len(index_grupos_cid) != 341:
    #    raise Exception("Tamanho da lista de grupos CID, para indexação do DataFrame, não corresponde a 341 entradas")
    #########

    # Cria um índice hierárquico
    df.set_index([index_grupos_cid, [i for i in range(len(index_grupos_cid))]], inplace=True)

    # Troca o valor da linha, na coluna 'Lista Morb  CID-10', para refletir o total do grupo
    df.loc[df.loc[:]['Lista Morb  CID-10'].str.match(r'[0-9]+'), 'Lista Morb  CID-10'] = 'Total do Grupo'

    # Retira os pontos no início das strings dos valores da coluna 'Lista Morb  CID-10'
    df.loc[:]['Lista Morb  CID-10'] = df.loc[:]['Lista Morb  CID-10'].apply(lambda x: x.strip('.'))

    return df

"""# Criação dos DataFrames"""

def criar_df_mensal():
    lista_caminhos = baixar_dados()
    dict_df_2019 = {}
    dict_df_2020 = {}
    for indice, caminho in enumerate(lista_caminhos):
        if '2019' in caminho:
            mes = MESES[indice]
            print(mes)
            df = ler_df(caminho)
            dict_df_2019[mes] = df
        elif '2020' in caminho:
            mes = MESES[indice-12]
            print(mes)
            df = ler_df(caminho)
            dict_df_2020[mes] = df
        else:
            raise ("Erro no caminho. Finalizado em ", caminho, indice)
    return dict_df_2019, dict_df_2020

def criar_df_anual(ano):
    if ano == 2019:
        _, _ = urllib.request.urlretrieve(URL_2019, filename=CAMINHO_2019)
        df = ler_df_anual(CAMINHO_2019)
        return df
    elif ano == 2020:
        _, _ = urllib.request.urlretrieve(URL_2020, filename=CAMINHO_2020)
        df = ler_df_anual(CAMINHO_2020)
        return df
    else:
        print("Ano inválido")